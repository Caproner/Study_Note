# 操作系统笔记

补习一下操作系统，防止面试翻车

## 第一章 操作系统概述

+ 操作系统的特征：并发、共享、虚拟、异步

  + 其中并发和共享是操作系统的两个最基本的特征

+ 并发与并行的区别

  并发是指多个任务轮流进行

  并行是指多个任务实时地同时进行

+ 两种资源共享方式

  + 互斥共享方式：访问时对资源上锁，一次只让一个进程访问该资源
  + 同时访问方式：不加锁，一段时间内可以允许多个进程同时访问
    + 也有可能是宏观上同时访问，而在实际上是分时共享的形式

+ 特权指令与非特权指令

  + 核心态可以执行所有指令，用户态只能执行非特权指令
  + 当在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令
  + 从用户态转换为核心态额唯一途径是中断或异常

+ 访管指令与访管中断

  当用户态下的进程需要执行一些特权指令时，需要使用访管指令向操作系统发出请求。之后产生一个中断事件。称为访管中断。进程中断之后操作系统进入核心态，运行需要运行的特权指令，完成之后退出中断，返回到用户进程断点继续执行

## 第二章 进程管理

### 进程控制

+ 进程创建
  + 为新进程分配一个唯一的进程标识符，并申请一个空的PCB
    + 若在此步PCB申请失败则进程创建失败
  + 为进程分配资源（程序、数据、用户栈的必要空间等）
    + 在这里如果分配资源失败（内存不足或其他的原因），则在其之后将进程置为阻塞态并置入等待队列中
  + 初始化PCB的信息
  + 如果就绪队列能接纳新进程则将其置入就绪队列

+ 进程终止
  + 根据被终止的进程的标识符，找到进程的PCB
  + 若被终止的进程处于执行状态，立刻终止该进程的执行，将处理机资源分配给其他进程
  + 若该进程还有子进程，则终止其子进程（递归进程终止）
  + 将该进程的所有资源归还给父进程或操作系统
  + 将该进程的PCB删除

+ 进程阻塞
  + 根据被阻塞的进程的标识符，找到进程的PCB
  + 若该进程为运行态，则保护其现场，将其转换为阻塞态，停止运行
  + 把该PCB插入到相应事件的等待队列中去

+ 进程唤醒
  + 根据被唤醒的进程的标识符，找到进程的PCB
  + 将其从等待队列中移出，并将其置为就绪态
  + 把该PCB插入到就绪队列中

+ 进程切换
  + 保存处理机上下文
  + 更新PCB的信息
  + 把PCB移入相应的队列中（一般是就绪队列，也有可能是等待队列）
  + 选择另一个进程执行，并更新其PCB
  + 更新内存管理了的数据结构
  + 恢复处理机上下文

### 进程的组织

+ PCB
  + 进程描述信息
    + 进程标识符（PID）
    + 用户标识符（UID）
  + 进程控制和管理信息
    + 进程当前状态
    + 进程优先级
    + 。。。
  + 资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况、所打开文件的列表和所使用的输入输出设备信息
  + 处理机相关信息：主要指处理机中各寄存器值
+ 程序段
+ 数据段

### 进程通信

+ 共享存储：即为存在一块共享空间可以给多个进程访问，这些进程可以借助这块空间实现通信

+ 消息传递：两个进程间通过操作系统提供的方式传递消息

  + 直接通信方式：发送进程直接将信息发到接收进程
  + 间接通信方式：发送进程将信息发到某个中间实体（相当于信箱），接收进程从中间实体中取得消息

+ 管道通信：使用管道文件实现进程间的通信

  在两个进程之间有两个管道文件，一个是由A进程写，B进程读，另一个相反

  管道文件事实上可以看做是一个单向的消息队列

  在Linux中，管道文件的大小被限制为最大4KB

### 进程与线程的比较

+ 进程与线程是一对多的关系，一个进程可以对应多个线程
+ 线程是独立调度的基本单位，进程是拥有资源的基本单位
+ 线程不拥有资源（准确地说应该是拥有少量资源如线程控制块等，但比起进程来说会少很多）
+ 引入多线程之后，不仅进程间可以并发执行，进程内的多个线程也可以并发执行，提高了操作系统的并发性
+ 创建或删除进程、以及切换进程的系统时空开销要比线程做相同的动作大很多
+ 进程间通信需要同步/互斥等手段辅助，而同一个进程的线程之间共享进程的资源，可以利用其进行通信

+ 在引入多线程之后，进程的【执行】事实上就是进程中的某一个线程在【执行】

## 第三章 内存管理

## 第四章 文件管理

## 第五章 I/O管理