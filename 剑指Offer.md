# 剑指Offer笔记

总结了一些自己需要注意的东西

## 第1章 面试的流程

+ 在面试题中，鲁棒性>时空效率
+ 对于最后问面试官的问题，应当是所在组的工作内容和自己的职位需要做的事情，防止像tx那次那样翻车

## 第2章 面试需要的基础知识

+ 关于`sizeof`
	+ 对一个没有任何成员的空类型求`sizeof`，答案为1而**不是0**
		+ 空类型的实例中不包含任何信息，本来求`sizeof`应该是0，但是当我们声明该类型的实例的时候，它**必须在内存中占有一定的空间**，否则无法使用这些实例。至于占用多少内存，由编译器决定。在Visual Studio中，每个空类型的实例占用1字节的空间
	+ 对一个只用构造函数和析构函数的空类型求`sizeof`，结果于对完全空的类型求`sizeof`结果一致
		+ 调用构造函数和析构函数只需要知道函数的地址即可，而**类中的函数的地址只与类型有关，而与类型的实例无关（不单单是构造函数和析构函数，其他函数也是）**，编译器也不会因为这两个函数而在实例内添加任何额外的信息。
	+ 对一个只有一个虚函数的类型求`sizeof`，结果却不是为1
		+ C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型中的每一个实例中添加一个指向虚函数表的指针（注意**不论该类型有多少个虚函数，对应的虚函数表只有一个，也就是指向虚函数表的指针有且仅有一个**）。那么该类型的大小便为一个指针的大小（32位系统中为4，64位系统中为8）
+ 复制构造函数中的参数必须是常引用（`const &`）的原因是防止其无限递归调用复制构造函数
+ 在编写类函数中需要考虑到的几个问题
	+ 内存泄漏
	+ 递归复制
	+ 异常安全性

## 第7章 两个面试案例

+ 在面试题中，鲁棒性>时空效率
	+ 虽然在上面已经说过了，不过这真的十分重要。面试题不是ACM题，各种奇奇怪怪的输入都有可能，需要时刻考虑异常处理
+ 在C++中，成员变量在构造函数中的初始化顺序只与它们在类中声明的顺序有关，而与构造函数中的初始化顺序无关